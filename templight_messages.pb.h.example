// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: templight_messages.proto

#ifndef PROTOBUF_templight_5fmessages_2eproto__INCLUDED
#define PROTOBUF_templight_5fmessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_templight_5fmessages_2eproto();
void protobuf_AssignDesc_templight_5fmessages_2eproto();
void protobuf_ShutdownFile_templight_5fmessages_2eproto();

class TemplightHeader;
class TemplightEntry;
class TemplightEntry_TemplateName;
class TemplightEntry_SourceLocation;
class TemplightEntry_Begin;
class TemplightEntry_End;
class TemplightTrace;
class TemplightTraceCollection;

enum TemplightEntry_InstantiationKind {
  TemplightEntry_InstantiationKind_TemplateInstantiation = 0,
  TemplightEntry_InstantiationKind_DefaultTemplateArgumentInstantiation = 1,
  TemplightEntry_InstantiationKind_DefaultFunctionArgumentInstantiation = 2,
  TemplightEntry_InstantiationKind_ExplicitTemplateArgumentSubstitution = 3,
  TemplightEntry_InstantiationKind_DeducedTemplateArgumentSubstitution = 4,
  TemplightEntry_InstantiationKind_PriorTemplateArgumentSubstitution = 5,
  TemplightEntry_InstantiationKind_DefaultTemplateArgumentChecking = 6,
  TemplightEntry_InstantiationKind_ExceptionSpecInstantiation = 7,
  TemplightEntry_InstantiationKind_Memoization = 8
};
bool TemplightEntry_InstantiationKind_IsValid(int value);
const TemplightEntry_InstantiationKind TemplightEntry_InstantiationKind_InstantiationKind_MIN = TemplightEntry_InstantiationKind_TemplateInstantiation;
const TemplightEntry_InstantiationKind TemplightEntry_InstantiationKind_InstantiationKind_MAX = TemplightEntry_InstantiationKind_Memoization;
const int TemplightEntry_InstantiationKind_InstantiationKind_ARRAYSIZE = TemplightEntry_InstantiationKind_InstantiationKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* TemplightEntry_InstantiationKind_descriptor();
inline const ::std::string& TemplightEntry_InstantiationKind_Name(TemplightEntry_InstantiationKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    TemplightEntry_InstantiationKind_descriptor(), value);
}
inline bool TemplightEntry_InstantiationKind_Parse(
    const ::std::string& name, TemplightEntry_InstantiationKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TemplightEntry_InstantiationKind>(
    TemplightEntry_InstantiationKind_descriptor(), name, value);
}
// ===================================================================

class TemplightHeader : public ::google::protobuf::Message {
 public:
  TemplightHeader();
  virtual ~TemplightHeader();

  TemplightHeader(const TemplightHeader& from);

  inline TemplightHeader& operator=(const TemplightHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TemplightHeader& default_instance();

  void Swap(TemplightHeader* other);

  // implements Message ----------------------------------------------

  TemplightHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TemplightHeader& from);
  void MergeFrom(const TemplightHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // optional string source_file = 2;
  inline bool has_source_file() const;
  inline void clear_source_file();
  static const int kSourceFileFieldNumber = 2;
  inline const ::std::string& source_file() const;
  inline void set_source_file(const ::std::string& value);
  inline void set_source_file(const char* value);
  inline void set_source_file(const char* value, size_t size);
  inline ::std::string* mutable_source_file();
  inline ::std::string* release_source_file();
  inline void set_allocated_source_file(::std::string* source_file);

  // @@protoc_insertion_point(class_scope:TemplightHeader)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_source_file();
  inline void clear_has_source_file();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* source_file_;
  ::google::protobuf::uint32 version_;
  friend void  protobuf_AddDesc_templight_5fmessages_2eproto();
  friend void protobuf_AssignDesc_templight_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_templight_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static TemplightHeader* default_instance_;
};
// -------------------------------------------------------------------

class TemplightEntry_TemplateName : public ::google::protobuf::Message {
 public:
  TemplightEntry_TemplateName();
  virtual ~TemplightEntry_TemplateName();

  TemplightEntry_TemplateName(const TemplightEntry_TemplateName& from);

  inline TemplightEntry_TemplateName& operator=(const TemplightEntry_TemplateName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TemplightEntry_TemplateName& default_instance();

  void Swap(TemplightEntry_TemplateName* other);

  // implements Message ----------------------------------------------

  TemplightEntry_TemplateName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TemplightEntry_TemplateName& from);
  void MergeFrom(const TemplightEntry_TemplateName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes compressed_name = 2;
  inline bool has_compressed_name() const;
  inline void clear_compressed_name();
  static const int kCompressedNameFieldNumber = 2;
  inline const ::std::string& compressed_name() const;
  inline void set_compressed_name(const ::std::string& value);
  inline void set_compressed_name(const char* value);
  inline void set_compressed_name(const void* value, size_t size);
  inline ::std::string* mutable_compressed_name();
  inline ::std::string* release_compressed_name();
  inline void set_allocated_compressed_name(::std::string* compressed_name);

  // @@protoc_insertion_point(class_scope:TemplightEntry.TemplateName)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_compressed_name();
  inline void clear_has_compressed_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* compressed_name_;
  friend void  protobuf_AddDesc_templight_5fmessages_2eproto();
  friend void protobuf_AssignDesc_templight_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_templight_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static TemplightEntry_TemplateName* default_instance_;
};
// -------------------------------------------------------------------

class TemplightEntry_SourceLocation : public ::google::protobuf::Message {
 public:
  TemplightEntry_SourceLocation();
  virtual ~TemplightEntry_SourceLocation();

  TemplightEntry_SourceLocation(const TemplightEntry_SourceLocation& from);

  inline TemplightEntry_SourceLocation& operator=(const TemplightEntry_SourceLocation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TemplightEntry_SourceLocation& default_instance();

  void Swap(TemplightEntry_SourceLocation* other);

  // implements Message ----------------------------------------------

  TemplightEntry_SourceLocation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TemplightEntry_SourceLocation& from);
  void MergeFrom(const TemplightEntry_SourceLocation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_name = 1;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // required uint32 file_id = 2;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  inline ::google::protobuf::uint32 file_id() const;
  inline void set_file_id(::google::protobuf::uint32 value);

  // required uint32 line = 3;
  inline bool has_line() const;
  inline void clear_line();
  static const int kLineFieldNumber = 3;
  inline ::google::protobuf::uint32 line() const;
  inline void set_line(::google::protobuf::uint32 value);

  // optional uint32 column = 4;
  inline bool has_column() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 4;
  inline ::google::protobuf::uint32 column() const;
  inline void set_column(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TemplightEntry.SourceLocation)
 private:
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_line();
  inline void clear_has_line();
  inline void set_has_column();
  inline void clear_has_column();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* file_name_;
  ::google::protobuf::uint32 file_id_;
  ::google::protobuf::uint32 line_;
  ::google::protobuf::uint32 column_;
  friend void  protobuf_AddDesc_templight_5fmessages_2eproto();
  friend void protobuf_AssignDesc_templight_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_templight_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static TemplightEntry_SourceLocation* default_instance_;
};
// -------------------------------------------------------------------

class TemplightEntry_Begin : public ::google::protobuf::Message {
 public:
  TemplightEntry_Begin();
  virtual ~TemplightEntry_Begin();

  TemplightEntry_Begin(const TemplightEntry_Begin& from);

  inline TemplightEntry_Begin& operator=(const TemplightEntry_Begin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TemplightEntry_Begin& default_instance();

  void Swap(TemplightEntry_Begin* other);

  // implements Message ----------------------------------------------

  TemplightEntry_Begin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TemplightEntry_Begin& from);
  void MergeFrom(const TemplightEntry_Begin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TemplightEntry.InstantiationKind kind = 1;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 1;
  inline ::TemplightEntry_InstantiationKind kind() const;
  inline void set_kind(::TemplightEntry_InstantiationKind value);

  // required .TemplightEntry.TemplateName name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::TemplightEntry_TemplateName& name() const;
  inline ::TemplightEntry_TemplateName* mutable_name();
  inline ::TemplightEntry_TemplateName* release_name();
  inline void set_allocated_name(::TemplightEntry_TemplateName* name);

  // required .TemplightEntry.SourceLocation location = 3;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 3;
  inline const ::TemplightEntry_SourceLocation& location() const;
  inline ::TemplightEntry_SourceLocation* mutable_location();
  inline ::TemplightEntry_SourceLocation* release_location();
  inline void set_allocated_location(::TemplightEntry_SourceLocation* location);

  // optional double time_stamp = 4;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 4;
  inline double time_stamp() const;
  inline void set_time_stamp(double value);

  // optional uint64 memory_usage = 5;
  inline bool has_memory_usage() const;
  inline void clear_memory_usage();
  static const int kMemoryUsageFieldNumber = 5;
  inline ::google::protobuf::uint64 memory_usage() const;
  inline void set_memory_usage(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:TemplightEntry.Begin)
 private:
  inline void set_has_kind();
  inline void clear_has_kind();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_memory_usage();
  inline void clear_has_memory_usage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::TemplightEntry_TemplateName* name_;
  ::TemplightEntry_SourceLocation* location_;
  double time_stamp_;
  ::google::protobuf::uint64 memory_usage_;
  int kind_;
  friend void  protobuf_AddDesc_templight_5fmessages_2eproto();
  friend void protobuf_AssignDesc_templight_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_templight_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static TemplightEntry_Begin* default_instance_;
};
// -------------------------------------------------------------------

class TemplightEntry_End : public ::google::protobuf::Message {
 public:
  TemplightEntry_End();
  virtual ~TemplightEntry_End();

  TemplightEntry_End(const TemplightEntry_End& from);

  inline TemplightEntry_End& operator=(const TemplightEntry_End& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TemplightEntry_End& default_instance();

  void Swap(TemplightEntry_End* other);

  // implements Message ----------------------------------------------

  TemplightEntry_End* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TemplightEntry_End& from);
  void MergeFrom(const TemplightEntry_End& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double time_stamp = 1;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 1;
  inline double time_stamp() const;
  inline void set_time_stamp(double value);

  // optional uint64 memory_usage = 2;
  inline bool has_memory_usage() const;
  inline void clear_memory_usage();
  static const int kMemoryUsageFieldNumber = 2;
  inline ::google::protobuf::uint64 memory_usage() const;
  inline void set_memory_usage(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:TemplightEntry.End)
 private:
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_memory_usage();
  inline void clear_has_memory_usage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double time_stamp_;
  ::google::protobuf::uint64 memory_usage_;
  friend void  protobuf_AddDesc_templight_5fmessages_2eproto();
  friend void protobuf_AssignDesc_templight_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_templight_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static TemplightEntry_End* default_instance_;
};
// -------------------------------------------------------------------

class TemplightEntry : public ::google::protobuf::Message {
 public:
  TemplightEntry();
  virtual ~TemplightEntry();

  TemplightEntry(const TemplightEntry& from);

  inline TemplightEntry& operator=(const TemplightEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TemplightEntry& default_instance();

  void Swap(TemplightEntry* other);

  // implements Message ----------------------------------------------

  TemplightEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TemplightEntry& from);
  void MergeFrom(const TemplightEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TemplightEntry_TemplateName TemplateName;
  typedef TemplightEntry_SourceLocation SourceLocation;
  typedef TemplightEntry_Begin Begin;
  typedef TemplightEntry_End End;

  typedef TemplightEntry_InstantiationKind InstantiationKind;
  static const InstantiationKind TemplateInstantiation = TemplightEntry_InstantiationKind_TemplateInstantiation;
  static const InstantiationKind DefaultTemplateArgumentInstantiation = TemplightEntry_InstantiationKind_DefaultTemplateArgumentInstantiation;
  static const InstantiationKind DefaultFunctionArgumentInstantiation = TemplightEntry_InstantiationKind_DefaultFunctionArgumentInstantiation;
  static const InstantiationKind ExplicitTemplateArgumentSubstitution = TemplightEntry_InstantiationKind_ExplicitTemplateArgumentSubstitution;
  static const InstantiationKind DeducedTemplateArgumentSubstitution = TemplightEntry_InstantiationKind_DeducedTemplateArgumentSubstitution;
  static const InstantiationKind PriorTemplateArgumentSubstitution = TemplightEntry_InstantiationKind_PriorTemplateArgumentSubstitution;
  static const InstantiationKind DefaultTemplateArgumentChecking = TemplightEntry_InstantiationKind_DefaultTemplateArgumentChecking;
  static const InstantiationKind ExceptionSpecInstantiation = TemplightEntry_InstantiationKind_ExceptionSpecInstantiation;
  static const InstantiationKind Memoization = TemplightEntry_InstantiationKind_Memoization;
  static inline bool InstantiationKind_IsValid(int value) {
    return TemplightEntry_InstantiationKind_IsValid(value);
  }
  static const InstantiationKind InstantiationKind_MIN =
    TemplightEntry_InstantiationKind_InstantiationKind_MIN;
  static const InstantiationKind InstantiationKind_MAX =
    TemplightEntry_InstantiationKind_InstantiationKind_MAX;
  static const int InstantiationKind_ARRAYSIZE =
    TemplightEntry_InstantiationKind_InstantiationKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  InstantiationKind_descriptor() {
    return TemplightEntry_InstantiationKind_descriptor();
  }
  static inline const ::std::string& InstantiationKind_Name(InstantiationKind value) {
    return TemplightEntry_InstantiationKind_Name(value);
  }
  static inline bool InstantiationKind_Parse(const ::std::string& name,
      InstantiationKind* value) {
    return TemplightEntry_InstantiationKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TemplightEntry.Begin begin = 1;
  inline bool has_begin() const;
  inline void clear_begin();
  static const int kBeginFieldNumber = 1;
  inline const ::TemplightEntry_Begin& begin() const;
  inline ::TemplightEntry_Begin* mutable_begin();
  inline ::TemplightEntry_Begin* release_begin();
  inline void set_allocated_begin(::TemplightEntry_Begin* begin);

  // optional .TemplightEntry.End end = 2;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 2;
  inline const ::TemplightEntry_End& end() const;
  inline ::TemplightEntry_End* mutable_end();
  inline ::TemplightEntry_End* release_end();
  inline void set_allocated_end(::TemplightEntry_End* end);

  // @@protoc_insertion_point(class_scope:TemplightEntry)
 private:
  inline void set_has_begin();
  inline void clear_has_begin();
  inline void set_has_end();
  inline void clear_has_end();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::TemplightEntry_Begin* begin_;
  ::TemplightEntry_End* end_;
  friend void  protobuf_AddDesc_templight_5fmessages_2eproto();
  friend void protobuf_AssignDesc_templight_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_templight_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static TemplightEntry* default_instance_;
};
// -------------------------------------------------------------------

class TemplightTrace : public ::google::protobuf::Message {
 public:
  TemplightTrace();
  virtual ~TemplightTrace();

  TemplightTrace(const TemplightTrace& from);

  inline TemplightTrace& operator=(const TemplightTrace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TemplightTrace& default_instance();

  void Swap(TemplightTrace* other);

  // implements Message ----------------------------------------------

  TemplightTrace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TemplightTrace& from);
  void MergeFrom(const TemplightTrace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TemplightHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::TemplightHeader& header() const;
  inline ::TemplightHeader* mutable_header();
  inline ::TemplightHeader* release_header();
  inline void set_allocated_header(::TemplightHeader* header);

  // repeated .TemplightEntry entries = 2;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 2;
  inline const ::TemplightEntry& entries(int index) const;
  inline ::TemplightEntry* mutable_entries(int index);
  inline ::TemplightEntry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::TemplightEntry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::TemplightEntry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:TemplightTrace)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::TemplightHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::TemplightEntry > entries_;
  friend void  protobuf_AddDesc_templight_5fmessages_2eproto();
  friend void protobuf_AssignDesc_templight_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_templight_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static TemplightTrace* default_instance_;
};
// -------------------------------------------------------------------

class TemplightTraceCollection : public ::google::protobuf::Message {
 public:
  TemplightTraceCollection();
  virtual ~TemplightTraceCollection();

  TemplightTraceCollection(const TemplightTraceCollection& from);

  inline TemplightTraceCollection& operator=(const TemplightTraceCollection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TemplightTraceCollection& default_instance();

  void Swap(TemplightTraceCollection* other);

  // implements Message ----------------------------------------------

  TemplightTraceCollection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TemplightTraceCollection& from);
  void MergeFrom(const TemplightTraceCollection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TemplightTrace traces = 1;
  inline int traces_size() const;
  inline void clear_traces();
  static const int kTracesFieldNumber = 1;
  inline const ::TemplightTrace& traces(int index) const;
  inline ::TemplightTrace* mutable_traces(int index);
  inline ::TemplightTrace* add_traces();
  inline const ::google::protobuf::RepeatedPtrField< ::TemplightTrace >&
      traces() const;
  inline ::google::protobuf::RepeatedPtrField< ::TemplightTrace >*
      mutable_traces();

  // @@protoc_insertion_point(class_scope:TemplightTraceCollection)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TemplightTrace > traces_;
  friend void  protobuf_AddDesc_templight_5fmessages_2eproto();
  friend void protobuf_AssignDesc_templight_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_templight_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static TemplightTraceCollection* default_instance_;
};
// ===================================================================


// ===================================================================

// TemplightHeader

// required uint32 version = 1;
inline bool TemplightHeader::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TemplightHeader::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TemplightHeader::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TemplightHeader::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 TemplightHeader::version() const {
  // @@protoc_insertion_point(field_get:TemplightHeader.version)
  return version_;
}
inline void TemplightHeader::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:TemplightHeader.version)
}

// optional string source_file = 2;
inline bool TemplightHeader::has_source_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TemplightHeader::set_has_source_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TemplightHeader::clear_has_source_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TemplightHeader::clear_source_file() {
  if (source_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_file_->clear();
  }
  clear_has_source_file();
}
inline const ::std::string& TemplightHeader::source_file() const {
  // @@protoc_insertion_point(field_get:TemplightHeader.source_file)
  return *source_file_;
}
inline void TemplightHeader::set_source_file(const ::std::string& value) {
  set_has_source_file();
  if (source_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_file_ = new ::std::string;
  }
  source_file_->assign(value);
  // @@protoc_insertion_point(field_set:TemplightHeader.source_file)
}
inline void TemplightHeader::set_source_file(const char* value) {
  set_has_source_file();
  if (source_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_file_ = new ::std::string;
  }
  source_file_->assign(value);
  // @@protoc_insertion_point(field_set_char:TemplightHeader.source_file)
}
inline void TemplightHeader::set_source_file(const char* value, size_t size) {
  set_has_source_file();
  if (source_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_file_ = new ::std::string;
  }
  source_file_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TemplightHeader.source_file)
}
inline ::std::string* TemplightHeader::mutable_source_file() {
  set_has_source_file();
  if (source_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_file_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TemplightHeader.source_file)
  return source_file_;
}
inline ::std::string* TemplightHeader::release_source_file() {
  clear_has_source_file();
  if (source_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = source_file_;
    source_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TemplightHeader::set_allocated_source_file(::std::string* source_file) {
  if (source_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete source_file_;
  }
  if (source_file) {
    set_has_source_file();
    source_file_ = source_file;
  } else {
    clear_has_source_file();
    source_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TemplightHeader.source_file)
}

// -------------------------------------------------------------------

// TemplightEntry_TemplateName

// optional string name = 1;
inline bool TemplightEntry_TemplateName::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TemplightEntry_TemplateName::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TemplightEntry_TemplateName::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TemplightEntry_TemplateName::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TemplightEntry_TemplateName::name() const {
  // @@protoc_insertion_point(field_get:TemplightEntry.TemplateName.name)
  return *name_;
}
inline void TemplightEntry_TemplateName::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:TemplightEntry.TemplateName.name)
}
inline void TemplightEntry_TemplateName::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:TemplightEntry.TemplateName.name)
}
inline void TemplightEntry_TemplateName::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TemplightEntry.TemplateName.name)
}
inline ::std::string* TemplightEntry_TemplateName::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TemplightEntry.TemplateName.name)
  return name_;
}
inline ::std::string* TemplightEntry_TemplateName::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TemplightEntry_TemplateName::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TemplightEntry.TemplateName.name)
}

// optional bytes compressed_name = 2;
inline bool TemplightEntry_TemplateName::has_compressed_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TemplightEntry_TemplateName::set_has_compressed_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TemplightEntry_TemplateName::clear_has_compressed_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TemplightEntry_TemplateName::clear_compressed_name() {
  if (compressed_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compressed_name_->clear();
  }
  clear_has_compressed_name();
}
inline const ::std::string& TemplightEntry_TemplateName::compressed_name() const {
  // @@protoc_insertion_point(field_get:TemplightEntry.TemplateName.compressed_name)
  return *compressed_name_;
}
inline void TemplightEntry_TemplateName::set_compressed_name(const ::std::string& value) {
  set_has_compressed_name();
  if (compressed_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compressed_name_ = new ::std::string;
  }
  compressed_name_->assign(value);
  // @@protoc_insertion_point(field_set:TemplightEntry.TemplateName.compressed_name)
}
inline void TemplightEntry_TemplateName::set_compressed_name(const char* value) {
  set_has_compressed_name();
  if (compressed_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compressed_name_ = new ::std::string;
  }
  compressed_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:TemplightEntry.TemplateName.compressed_name)
}
inline void TemplightEntry_TemplateName::set_compressed_name(const void* value, size_t size) {
  set_has_compressed_name();
  if (compressed_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compressed_name_ = new ::std::string;
  }
  compressed_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TemplightEntry.TemplateName.compressed_name)
}
inline ::std::string* TemplightEntry_TemplateName::mutable_compressed_name() {
  set_has_compressed_name();
  if (compressed_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compressed_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TemplightEntry.TemplateName.compressed_name)
  return compressed_name_;
}
inline ::std::string* TemplightEntry_TemplateName::release_compressed_name() {
  clear_has_compressed_name();
  if (compressed_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = compressed_name_;
    compressed_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TemplightEntry_TemplateName::set_allocated_compressed_name(::std::string* compressed_name) {
  if (compressed_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete compressed_name_;
  }
  if (compressed_name) {
    set_has_compressed_name();
    compressed_name_ = compressed_name;
  } else {
    clear_has_compressed_name();
    compressed_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TemplightEntry.TemplateName.compressed_name)
}

// -------------------------------------------------------------------

// TemplightEntry_SourceLocation

// optional string file_name = 1;
inline bool TemplightEntry_SourceLocation::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TemplightEntry_SourceLocation::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TemplightEntry_SourceLocation::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TemplightEntry_SourceLocation::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& TemplightEntry_SourceLocation::file_name() const {
  // @@protoc_insertion_point(field_get:TemplightEntry.SourceLocation.file_name)
  return *file_name_;
}
inline void TemplightEntry_SourceLocation::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
  // @@protoc_insertion_point(field_set:TemplightEntry.SourceLocation.file_name)
}
inline void TemplightEntry_SourceLocation::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:TemplightEntry.SourceLocation.file_name)
}
inline void TemplightEntry_SourceLocation::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TemplightEntry.SourceLocation.file_name)
}
inline ::std::string* TemplightEntry_SourceLocation::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TemplightEntry.SourceLocation.file_name)
  return file_name_;
}
inline ::std::string* TemplightEntry_SourceLocation::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TemplightEntry_SourceLocation::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TemplightEntry.SourceLocation.file_name)
}

// required uint32 file_id = 2;
inline bool TemplightEntry_SourceLocation::has_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TemplightEntry_SourceLocation::set_has_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TemplightEntry_SourceLocation::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TemplightEntry_SourceLocation::clear_file_id() {
  file_id_ = 0u;
  clear_has_file_id();
}
inline ::google::protobuf::uint32 TemplightEntry_SourceLocation::file_id() const {
  // @@protoc_insertion_point(field_get:TemplightEntry.SourceLocation.file_id)
  return file_id_;
}
inline void TemplightEntry_SourceLocation::set_file_id(::google::protobuf::uint32 value) {
  set_has_file_id();
  file_id_ = value;
  // @@protoc_insertion_point(field_set:TemplightEntry.SourceLocation.file_id)
}

// required uint32 line = 3;
inline bool TemplightEntry_SourceLocation::has_line() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TemplightEntry_SourceLocation::set_has_line() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TemplightEntry_SourceLocation::clear_has_line() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TemplightEntry_SourceLocation::clear_line() {
  line_ = 0u;
  clear_has_line();
}
inline ::google::protobuf::uint32 TemplightEntry_SourceLocation::line() const {
  // @@protoc_insertion_point(field_get:TemplightEntry.SourceLocation.line)
  return line_;
}
inline void TemplightEntry_SourceLocation::set_line(::google::protobuf::uint32 value) {
  set_has_line();
  line_ = value;
  // @@protoc_insertion_point(field_set:TemplightEntry.SourceLocation.line)
}

// optional uint32 column = 4;
inline bool TemplightEntry_SourceLocation::has_column() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TemplightEntry_SourceLocation::set_has_column() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TemplightEntry_SourceLocation::clear_has_column() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TemplightEntry_SourceLocation::clear_column() {
  column_ = 0u;
  clear_has_column();
}
inline ::google::protobuf::uint32 TemplightEntry_SourceLocation::column() const {
  // @@protoc_insertion_point(field_get:TemplightEntry.SourceLocation.column)
  return column_;
}
inline void TemplightEntry_SourceLocation::set_column(::google::protobuf::uint32 value) {
  set_has_column();
  column_ = value;
  // @@protoc_insertion_point(field_set:TemplightEntry.SourceLocation.column)
}

// -------------------------------------------------------------------

// TemplightEntry_Begin

// required .TemplightEntry.InstantiationKind kind = 1;
inline bool TemplightEntry_Begin::has_kind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TemplightEntry_Begin::set_has_kind() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TemplightEntry_Begin::clear_has_kind() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TemplightEntry_Begin::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::TemplightEntry_InstantiationKind TemplightEntry_Begin::kind() const {
  // @@protoc_insertion_point(field_get:TemplightEntry.Begin.kind)
  return static_cast< ::TemplightEntry_InstantiationKind >(kind_);
}
inline void TemplightEntry_Begin::set_kind(::TemplightEntry_InstantiationKind value) {
  assert(::TemplightEntry_InstantiationKind_IsValid(value));
  set_has_kind();
  kind_ = value;
  // @@protoc_insertion_point(field_set:TemplightEntry.Begin.kind)
}

// required .TemplightEntry.TemplateName name = 2;
inline bool TemplightEntry_Begin::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TemplightEntry_Begin::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TemplightEntry_Begin::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TemplightEntry_Begin::clear_name() {
  if (name_ != NULL) name_->::TemplightEntry_TemplateName::Clear();
  clear_has_name();
}
inline const ::TemplightEntry_TemplateName& TemplightEntry_Begin::name() const {
  // @@protoc_insertion_point(field_get:TemplightEntry.Begin.name)
  return name_ != NULL ? *name_ : *default_instance_->name_;
}
inline ::TemplightEntry_TemplateName* TemplightEntry_Begin::mutable_name() {
  set_has_name();
  if (name_ == NULL) name_ = new ::TemplightEntry_TemplateName;
  // @@protoc_insertion_point(field_mutable:TemplightEntry.Begin.name)
  return name_;
}
inline ::TemplightEntry_TemplateName* TemplightEntry_Begin::release_name() {
  clear_has_name();
  ::TemplightEntry_TemplateName* temp = name_;
  name_ = NULL;
  return temp;
}
inline void TemplightEntry_Begin::set_allocated_name(::TemplightEntry_TemplateName* name) {
  delete name_;
  name_ = name;
  if (name) {
    set_has_name();
  } else {
    clear_has_name();
  }
  // @@protoc_insertion_point(field_set_allocated:TemplightEntry.Begin.name)
}

// required .TemplightEntry.SourceLocation location = 3;
inline bool TemplightEntry_Begin::has_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TemplightEntry_Begin::set_has_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TemplightEntry_Begin::clear_has_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TemplightEntry_Begin::clear_location() {
  if (location_ != NULL) location_->::TemplightEntry_SourceLocation::Clear();
  clear_has_location();
}
inline const ::TemplightEntry_SourceLocation& TemplightEntry_Begin::location() const {
  // @@protoc_insertion_point(field_get:TemplightEntry.Begin.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::TemplightEntry_SourceLocation* TemplightEntry_Begin::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::TemplightEntry_SourceLocation;
  // @@protoc_insertion_point(field_mutable:TemplightEntry.Begin.location)
  return location_;
}
inline ::TemplightEntry_SourceLocation* TemplightEntry_Begin::release_location() {
  clear_has_location();
  ::TemplightEntry_SourceLocation* temp = location_;
  location_ = NULL;
  return temp;
}
inline void TemplightEntry_Begin::set_allocated_location(::TemplightEntry_SourceLocation* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:TemplightEntry.Begin.location)
}

// optional double time_stamp = 4;
inline bool TemplightEntry_Begin::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TemplightEntry_Begin::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TemplightEntry_Begin::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TemplightEntry_Begin::clear_time_stamp() {
  time_stamp_ = 0;
  clear_has_time_stamp();
}
inline double TemplightEntry_Begin::time_stamp() const {
  // @@protoc_insertion_point(field_get:TemplightEntry.Begin.time_stamp)
  return time_stamp_;
}
inline void TemplightEntry_Begin::set_time_stamp(double value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:TemplightEntry.Begin.time_stamp)
}

// optional uint64 memory_usage = 5;
inline bool TemplightEntry_Begin::has_memory_usage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TemplightEntry_Begin::set_has_memory_usage() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TemplightEntry_Begin::clear_has_memory_usage() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TemplightEntry_Begin::clear_memory_usage() {
  memory_usage_ = GOOGLE_ULONGLONG(0);
  clear_has_memory_usage();
}
inline ::google::protobuf::uint64 TemplightEntry_Begin::memory_usage() const {
  // @@protoc_insertion_point(field_get:TemplightEntry.Begin.memory_usage)
  return memory_usage_;
}
inline void TemplightEntry_Begin::set_memory_usage(::google::protobuf::uint64 value) {
  set_has_memory_usage();
  memory_usage_ = value;
  // @@protoc_insertion_point(field_set:TemplightEntry.Begin.memory_usage)
}

// -------------------------------------------------------------------

// TemplightEntry_End

// optional double time_stamp = 1;
inline bool TemplightEntry_End::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TemplightEntry_End::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TemplightEntry_End::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TemplightEntry_End::clear_time_stamp() {
  time_stamp_ = 0;
  clear_has_time_stamp();
}
inline double TemplightEntry_End::time_stamp() const {
  // @@protoc_insertion_point(field_get:TemplightEntry.End.time_stamp)
  return time_stamp_;
}
inline void TemplightEntry_End::set_time_stamp(double value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:TemplightEntry.End.time_stamp)
}

// optional uint64 memory_usage = 2;
inline bool TemplightEntry_End::has_memory_usage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TemplightEntry_End::set_has_memory_usage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TemplightEntry_End::clear_has_memory_usage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TemplightEntry_End::clear_memory_usage() {
  memory_usage_ = GOOGLE_ULONGLONG(0);
  clear_has_memory_usage();
}
inline ::google::protobuf::uint64 TemplightEntry_End::memory_usage() const {
  // @@protoc_insertion_point(field_get:TemplightEntry.End.memory_usage)
  return memory_usage_;
}
inline void TemplightEntry_End::set_memory_usage(::google::protobuf::uint64 value) {
  set_has_memory_usage();
  memory_usage_ = value;
  // @@protoc_insertion_point(field_set:TemplightEntry.End.memory_usage)
}

// -------------------------------------------------------------------

// TemplightEntry

// optional .TemplightEntry.Begin begin = 1;
inline bool TemplightEntry::has_begin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TemplightEntry::set_has_begin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TemplightEntry::clear_has_begin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TemplightEntry::clear_begin() {
  if (begin_ != NULL) begin_->::TemplightEntry_Begin::Clear();
  clear_has_begin();
}
inline const ::TemplightEntry_Begin& TemplightEntry::begin() const {
  // @@protoc_insertion_point(field_get:TemplightEntry.begin)
  return begin_ != NULL ? *begin_ : *default_instance_->begin_;
}
inline ::TemplightEntry_Begin* TemplightEntry::mutable_begin() {
  set_has_begin();
  if (begin_ == NULL) begin_ = new ::TemplightEntry_Begin;
  // @@protoc_insertion_point(field_mutable:TemplightEntry.begin)
  return begin_;
}
inline ::TemplightEntry_Begin* TemplightEntry::release_begin() {
  clear_has_begin();
  ::TemplightEntry_Begin* temp = begin_;
  begin_ = NULL;
  return temp;
}
inline void TemplightEntry::set_allocated_begin(::TemplightEntry_Begin* begin) {
  delete begin_;
  begin_ = begin;
  if (begin) {
    set_has_begin();
  } else {
    clear_has_begin();
  }
  // @@protoc_insertion_point(field_set_allocated:TemplightEntry.begin)
}

// optional .TemplightEntry.End end = 2;
inline bool TemplightEntry::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TemplightEntry::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TemplightEntry::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TemplightEntry::clear_end() {
  if (end_ != NULL) end_->::TemplightEntry_End::Clear();
  clear_has_end();
}
inline const ::TemplightEntry_End& TemplightEntry::end() const {
  // @@protoc_insertion_point(field_get:TemplightEntry.end)
  return end_ != NULL ? *end_ : *default_instance_->end_;
}
inline ::TemplightEntry_End* TemplightEntry::mutable_end() {
  set_has_end();
  if (end_ == NULL) end_ = new ::TemplightEntry_End;
  // @@protoc_insertion_point(field_mutable:TemplightEntry.end)
  return end_;
}
inline ::TemplightEntry_End* TemplightEntry::release_end() {
  clear_has_end();
  ::TemplightEntry_End* temp = end_;
  end_ = NULL;
  return temp;
}
inline void TemplightEntry::set_allocated_end(::TemplightEntry_End* end) {
  delete end_;
  end_ = end;
  if (end) {
    set_has_end();
  } else {
    clear_has_end();
  }
  // @@protoc_insertion_point(field_set_allocated:TemplightEntry.end)
}

// -------------------------------------------------------------------

// TemplightTrace

// required .TemplightHeader header = 1;
inline bool TemplightTrace::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TemplightTrace::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TemplightTrace::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TemplightTrace::clear_header() {
  if (header_ != NULL) header_->::TemplightHeader::Clear();
  clear_has_header();
}
inline const ::TemplightHeader& TemplightTrace::header() const {
  // @@protoc_insertion_point(field_get:TemplightTrace.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::TemplightHeader* TemplightTrace::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::TemplightHeader;
  // @@protoc_insertion_point(field_mutable:TemplightTrace.header)
  return header_;
}
inline ::TemplightHeader* TemplightTrace::release_header() {
  clear_has_header();
  ::TemplightHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void TemplightTrace::set_allocated_header(::TemplightHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:TemplightTrace.header)
}

// repeated .TemplightEntry entries = 2;
inline int TemplightTrace::entries_size() const {
  return entries_.size();
}
inline void TemplightTrace::clear_entries() {
  entries_.Clear();
}
inline const ::TemplightEntry& TemplightTrace::entries(int index) const {
  // @@protoc_insertion_point(field_get:TemplightTrace.entries)
  return entries_.Get(index);
}
inline ::TemplightEntry* TemplightTrace::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:TemplightTrace.entries)
  return entries_.Mutable(index);
}
inline ::TemplightEntry* TemplightTrace::add_entries() {
  // @@protoc_insertion_point(field_add:TemplightTrace.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TemplightEntry >&
TemplightTrace::entries() const {
  // @@protoc_insertion_point(field_list:TemplightTrace.entries)
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::TemplightEntry >*
TemplightTrace::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:TemplightTrace.entries)
  return &entries_;
}

// -------------------------------------------------------------------

// TemplightTraceCollection

// repeated .TemplightTrace traces = 1;
inline int TemplightTraceCollection::traces_size() const {
  return traces_.size();
}
inline void TemplightTraceCollection::clear_traces() {
  traces_.Clear();
}
inline const ::TemplightTrace& TemplightTraceCollection::traces(int index) const {
  // @@protoc_insertion_point(field_get:TemplightTraceCollection.traces)
  return traces_.Get(index);
}
inline ::TemplightTrace* TemplightTraceCollection::mutable_traces(int index) {
  // @@protoc_insertion_point(field_mutable:TemplightTraceCollection.traces)
  return traces_.Mutable(index);
}
inline ::TemplightTrace* TemplightTraceCollection::add_traces() {
  // @@protoc_insertion_point(field_add:TemplightTraceCollection.traces)
  return traces_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TemplightTrace >&
TemplightTraceCollection::traces() const {
  // @@protoc_insertion_point(field_list:TemplightTraceCollection.traces)
  return traces_;
}
inline ::google::protobuf::RepeatedPtrField< ::TemplightTrace >*
TemplightTraceCollection::mutable_traces() {
  // @@protoc_insertion_point(field_mutable_list:TemplightTraceCollection.traces)
  return &traces_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::TemplightEntry_InstantiationKind> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TemplightEntry_InstantiationKind>() {
  return ::TemplightEntry_InstantiationKind_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_templight_5fmessages_2eproto__INCLUDED
