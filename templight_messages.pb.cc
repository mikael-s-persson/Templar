// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: templight_messages.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "templight_messages.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* TemplightHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TemplightHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* TemplightEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TemplightEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* TemplightEntry_TemplateName_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TemplightEntry_TemplateName_reflection_ = NULL;
const ::google::protobuf::Descriptor* TemplightEntry_SourceLocation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TemplightEntry_SourceLocation_reflection_ = NULL;
const ::google::protobuf::Descriptor* TemplightEntry_Begin_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TemplightEntry_Begin_reflection_ = NULL;
const ::google::protobuf::Descriptor* TemplightEntry_End_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TemplightEntry_End_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* TemplightEntry_InstantiationKind_descriptor_ = NULL;
const ::google::protobuf::Descriptor* TemplightTrace_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TemplightTrace_reflection_ = NULL;
const ::google::protobuf::Descriptor* TemplightTraceCollection_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TemplightTraceCollection_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_templight_5fmessages_2eproto() {
  protobuf_AddDesc_templight_5fmessages_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "templight_messages.proto");
  GOOGLE_CHECK(file != NULL);
  TemplightHeader_descriptor_ = file->message_type(0);
  static const int TemplightHeader_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightHeader, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightHeader, source_file_),
  };
  TemplightHeader_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TemplightHeader_descriptor_,
      TemplightHeader::default_instance_,
      TemplightHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightHeader, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightHeader, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TemplightHeader));
  TemplightEntry_descriptor_ = file->message_type(1);
  static const int TemplightEntry_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry, begin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry, end_),
  };
  TemplightEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TemplightEntry_descriptor_,
      TemplightEntry::default_instance_,
      TemplightEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TemplightEntry));
  TemplightEntry_TemplateName_descriptor_ = TemplightEntry_descriptor_->nested_type(0);
  static const int TemplightEntry_TemplateName_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry_TemplateName, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry_TemplateName, compressed_name_),
  };
  TemplightEntry_TemplateName_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TemplightEntry_TemplateName_descriptor_,
      TemplightEntry_TemplateName::default_instance_,
      TemplightEntry_TemplateName_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry_TemplateName, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry_TemplateName, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TemplightEntry_TemplateName));
  TemplightEntry_SourceLocation_descriptor_ = TemplightEntry_descriptor_->nested_type(1);
  static const int TemplightEntry_SourceLocation_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry_SourceLocation, file_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry_SourceLocation, file_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry_SourceLocation, line_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry_SourceLocation, column_),
  };
  TemplightEntry_SourceLocation_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TemplightEntry_SourceLocation_descriptor_,
      TemplightEntry_SourceLocation::default_instance_,
      TemplightEntry_SourceLocation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry_SourceLocation, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry_SourceLocation, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TemplightEntry_SourceLocation));
  TemplightEntry_Begin_descriptor_ = TemplightEntry_descriptor_->nested_type(2);
  static const int TemplightEntry_Begin_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry_Begin, kind_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry_Begin, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry_Begin, location_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry_Begin, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry_Begin, memory_usage_),
  };
  TemplightEntry_Begin_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TemplightEntry_Begin_descriptor_,
      TemplightEntry_Begin::default_instance_,
      TemplightEntry_Begin_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry_Begin, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry_Begin, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TemplightEntry_Begin));
  TemplightEntry_End_descriptor_ = TemplightEntry_descriptor_->nested_type(3);
  static const int TemplightEntry_End_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry_End, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry_End, memory_usage_),
  };
  TemplightEntry_End_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TemplightEntry_End_descriptor_,
      TemplightEntry_End::default_instance_,
      TemplightEntry_End_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry_End, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightEntry_End, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TemplightEntry_End));
  TemplightEntry_InstantiationKind_descriptor_ = TemplightEntry_descriptor_->enum_type(0);
  TemplightTrace_descriptor_ = file->message_type(2);
  static const int TemplightTrace_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightTrace, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightTrace, entries_),
  };
  TemplightTrace_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TemplightTrace_descriptor_,
      TemplightTrace::default_instance_,
      TemplightTrace_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightTrace, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightTrace, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TemplightTrace));
  TemplightTraceCollection_descriptor_ = file->message_type(3);
  static const int TemplightTraceCollection_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightTraceCollection, traces_),
  };
  TemplightTraceCollection_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TemplightTraceCollection_descriptor_,
      TemplightTraceCollection::default_instance_,
      TemplightTraceCollection_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightTraceCollection, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TemplightTraceCollection, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TemplightTraceCollection));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_templight_5fmessages_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TemplightHeader_descriptor_, &TemplightHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TemplightEntry_descriptor_, &TemplightEntry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TemplightEntry_TemplateName_descriptor_, &TemplightEntry_TemplateName::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TemplightEntry_SourceLocation_descriptor_, &TemplightEntry_SourceLocation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TemplightEntry_Begin_descriptor_, &TemplightEntry_Begin::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TemplightEntry_End_descriptor_, &TemplightEntry_End::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TemplightTrace_descriptor_, &TemplightTrace::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TemplightTraceCollection_descriptor_, &TemplightTraceCollection::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_templight_5fmessages_2eproto() {
  delete TemplightHeader::default_instance_;
  delete TemplightHeader_reflection_;
  delete TemplightEntry::default_instance_;
  delete TemplightEntry_reflection_;
  delete TemplightEntry_TemplateName::default_instance_;
  delete TemplightEntry_TemplateName_reflection_;
  delete TemplightEntry_SourceLocation::default_instance_;
  delete TemplightEntry_SourceLocation_reflection_;
  delete TemplightEntry_Begin::default_instance_;
  delete TemplightEntry_Begin_reflection_;
  delete TemplightEntry_End::default_instance_;
  delete TemplightEntry_End_reflection_;
  delete TemplightTrace::default_instance_;
  delete TemplightTrace_reflection_;
  delete TemplightTraceCollection::default_instance_;
  delete TemplightTraceCollection_reflection_;
}

void protobuf_AddDesc_templight_5fmessages_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\030templight_messages.proto\"7\n\017TemplightH"
    "eader\022\017\n\007version\030\001 \002(\r\022\023\n\013source_file\030\002 "
    "\001(\t\"\254\006\n\016TemplightEntry\022$\n\005begin\030\001 \001(\0132\025."
    "TemplightEntry.Begin\022 \n\003end\030\002 \001(\0132\023.Temp"
    "lightEntry.End\0325\n\014TemplateName\022\014\n\004name\030\001"
    " \001(\t\022\027\n\017compressed_name\030\002 \001(\014\032R\n\016SourceL"
    "ocation\022\021\n\tfile_name\030\001 \001(\t\022\017\n\007file_id\030\002 "
    "\002(\r\022\014\n\004line\030\003 \002(\r\022\016\n\006column\030\004 \001(\r\032\300\001\n\005Be"
    "gin\022/\n\004kind\030\001 \002(\0162!.TemplightEntry.Insta"
    "ntiationKind\022*\n\004name\030\002 \002(\0132\034.TemplightEn"
    "try.TemplateName\0220\n\010location\030\003 \002(\0132\036.Tem"
    "plightEntry.SourceLocation\022\022\n\ntime_stamp"
    "\030\004 \001(\001\022\024\n\014memory_usage\030\005 \001(\004\032/\n\003End\022\022\n\nt"
    "ime_stamp\030\001 \001(\001\022\024\n\014memory_usage\030\002 \001(\004\"\322\002"
    "\n\021InstantiationKind\022\031\n\025TemplateInstantia"
    "tion\020\000\022(\n$DefaultTemplateArgumentInstant"
    "iation\020\001\022(\n$DefaultFunctionArgumentInsta"
    "ntiation\020\002\022(\n$ExplicitTemplateArgumentSu"
    "bstitution\020\003\022\'\n#DeducedTemplateArgumentS"
    "ubstitution\020\004\022%\n!PriorTemplateArgumentSu"
    "bstitution\020\005\022#\n\037DefaultTemplateArgumentC"
    "hecking\020\006\022\036\n\032ExceptionSpecInstantiation\020"
    "\007\022\017\n\013Memoization\020\010\"T\n\016TemplightTrace\022 \n\006"
    "header\030\001 \002(\0132\020.TemplightHeader\022 \n\007entrie"
    "s\030\002 \003(\0132\017.TemplightEntry\";\n\030TemplightTra"
    "ceCollection\022\037\n\006traces\030\001 \003(\0132\017.Templight"
    "Trace", 1045);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "templight_messages.proto", &protobuf_RegisterTypes);
  TemplightHeader::default_instance_ = new TemplightHeader();
  TemplightEntry::default_instance_ = new TemplightEntry();
  TemplightEntry_TemplateName::default_instance_ = new TemplightEntry_TemplateName();
  TemplightEntry_SourceLocation::default_instance_ = new TemplightEntry_SourceLocation();
  TemplightEntry_Begin::default_instance_ = new TemplightEntry_Begin();
  TemplightEntry_End::default_instance_ = new TemplightEntry_End();
  TemplightTrace::default_instance_ = new TemplightTrace();
  TemplightTraceCollection::default_instance_ = new TemplightTraceCollection();
  TemplightHeader::default_instance_->InitAsDefaultInstance();
  TemplightEntry::default_instance_->InitAsDefaultInstance();
  TemplightEntry_TemplateName::default_instance_->InitAsDefaultInstance();
  TemplightEntry_SourceLocation::default_instance_->InitAsDefaultInstance();
  TemplightEntry_Begin::default_instance_->InitAsDefaultInstance();
  TemplightEntry_End::default_instance_->InitAsDefaultInstance();
  TemplightTrace::default_instance_->InitAsDefaultInstance();
  TemplightTraceCollection::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_templight_5fmessages_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_templight_5fmessages_2eproto {
  StaticDescriptorInitializer_templight_5fmessages_2eproto() {
    protobuf_AddDesc_templight_5fmessages_2eproto();
  }
} static_descriptor_initializer_templight_5fmessages_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int TemplightHeader::kVersionFieldNumber;
const int TemplightHeader::kSourceFileFieldNumber;
#endif  // !_MSC_VER

TemplightHeader::TemplightHeader()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:TemplightHeader)
}

void TemplightHeader::InitAsDefaultInstance() {
}

TemplightHeader::TemplightHeader(const TemplightHeader& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:TemplightHeader)
}

void TemplightHeader::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  version_ = 0u;
  source_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TemplightHeader::~TemplightHeader() {
  // @@protoc_insertion_point(destructor:TemplightHeader)
  SharedDtor();
}

void TemplightHeader::SharedDtor() {
  if (source_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete source_file_;
  }
  if (this != default_instance_) {
  }
}

void TemplightHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TemplightHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TemplightHeader_descriptor_;
}

const TemplightHeader& TemplightHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_templight_5fmessages_2eproto();
  return *default_instance_;
}

TemplightHeader* TemplightHeader::default_instance_ = NULL;

TemplightHeader* TemplightHeader::New() const {
  return new TemplightHeader;
}

void TemplightHeader::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    version_ = 0u;
    if (has_source_file()) {
      if (source_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        source_file_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TemplightHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TemplightHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_source_file;
        break;
      }

      // optional string source_file = 2;
      case 2: {
        if (tag == 18) {
         parse_source_file:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_source_file()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->source_file().data(), this->source_file().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "source_file");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TemplightHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TemplightHeader)
  return false;
#undef DO_
}

void TemplightHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TemplightHeader)
  // required uint32 version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }

  // optional string source_file = 2;
  if (has_source_file()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->source_file().data(), this->source_file().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "source_file");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->source_file(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TemplightHeader)
}

::google::protobuf::uint8* TemplightHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TemplightHeader)
  // required uint32 version = 1;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }

  // optional string source_file = 2;
  if (has_source_file()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->source_file().data(), this->source_file().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "source_file");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->source_file(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TemplightHeader)
  return target;
}

int TemplightHeader::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

    // optional string source_file = 2;
    if (has_source_file()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->source_file());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TemplightHeader::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TemplightHeader* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TemplightHeader*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TemplightHeader::MergeFrom(const TemplightHeader& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_source_file()) {
      set_source_file(from.source_file());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TemplightHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TemplightHeader::CopyFrom(const TemplightHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TemplightHeader::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void TemplightHeader::Swap(TemplightHeader* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(source_file_, other->source_file_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TemplightHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TemplightHeader_descriptor_;
  metadata.reflection = TemplightHeader_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* TemplightEntry_InstantiationKind_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TemplightEntry_InstantiationKind_descriptor_;
}
bool TemplightEntry_InstantiationKind_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const TemplightEntry_InstantiationKind TemplightEntry::TemplateInstantiation;
const TemplightEntry_InstantiationKind TemplightEntry::DefaultTemplateArgumentInstantiation;
const TemplightEntry_InstantiationKind TemplightEntry::DefaultFunctionArgumentInstantiation;
const TemplightEntry_InstantiationKind TemplightEntry::ExplicitTemplateArgumentSubstitution;
const TemplightEntry_InstantiationKind TemplightEntry::DeducedTemplateArgumentSubstitution;
const TemplightEntry_InstantiationKind TemplightEntry::PriorTemplateArgumentSubstitution;
const TemplightEntry_InstantiationKind TemplightEntry::DefaultTemplateArgumentChecking;
const TemplightEntry_InstantiationKind TemplightEntry::ExceptionSpecInstantiation;
const TemplightEntry_InstantiationKind TemplightEntry::Memoization;
const TemplightEntry_InstantiationKind TemplightEntry::InstantiationKind_MIN;
const TemplightEntry_InstantiationKind TemplightEntry::InstantiationKind_MAX;
const int TemplightEntry::InstantiationKind_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int TemplightEntry_TemplateName::kNameFieldNumber;
const int TemplightEntry_TemplateName::kCompressedNameFieldNumber;
#endif  // !_MSC_VER

TemplightEntry_TemplateName::TemplightEntry_TemplateName()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:TemplightEntry.TemplateName)
}

void TemplightEntry_TemplateName::InitAsDefaultInstance() {
}

TemplightEntry_TemplateName::TemplightEntry_TemplateName(const TemplightEntry_TemplateName& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:TemplightEntry.TemplateName)
}

void TemplightEntry_TemplateName::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  compressed_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TemplightEntry_TemplateName::~TemplightEntry_TemplateName() {
  // @@protoc_insertion_point(destructor:TemplightEntry.TemplateName)
  SharedDtor();
}

void TemplightEntry_TemplateName::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (compressed_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete compressed_name_;
  }
  if (this != default_instance_) {
  }
}

void TemplightEntry_TemplateName::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TemplightEntry_TemplateName::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TemplightEntry_TemplateName_descriptor_;
}

const TemplightEntry_TemplateName& TemplightEntry_TemplateName::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_templight_5fmessages_2eproto();
  return *default_instance_;
}

TemplightEntry_TemplateName* TemplightEntry_TemplateName::default_instance_ = NULL;

TemplightEntry_TemplateName* TemplightEntry_TemplateName::New() const {
  return new TemplightEntry_TemplateName;
}

void TemplightEntry_TemplateName::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_compressed_name()) {
      if (compressed_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        compressed_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TemplightEntry_TemplateName::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TemplightEntry.TemplateName)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_compressed_name;
        break;
      }

      // optional bytes compressed_name = 2;
      case 2: {
        if (tag == 18) {
         parse_compressed_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_compressed_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TemplightEntry.TemplateName)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TemplightEntry.TemplateName)
  return false;
#undef DO_
}

void TemplightEntry_TemplateName::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TemplightEntry.TemplateName)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional bytes compressed_name = 2;
  if (has_compressed_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->compressed_name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TemplightEntry.TemplateName)
}

::google::protobuf::uint8* TemplightEntry_TemplateName::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TemplightEntry.TemplateName)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional bytes compressed_name = 2;
  if (has_compressed_name()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->compressed_name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TemplightEntry.TemplateName)
  return target;
}

int TemplightEntry_TemplateName::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional bytes compressed_name = 2;
    if (has_compressed_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->compressed_name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TemplightEntry_TemplateName::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TemplightEntry_TemplateName* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TemplightEntry_TemplateName*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TemplightEntry_TemplateName::MergeFrom(const TemplightEntry_TemplateName& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_compressed_name()) {
      set_compressed_name(from.compressed_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TemplightEntry_TemplateName::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TemplightEntry_TemplateName::CopyFrom(const TemplightEntry_TemplateName& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TemplightEntry_TemplateName::IsInitialized() const {

  return true;
}

void TemplightEntry_TemplateName::Swap(TemplightEntry_TemplateName* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(compressed_name_, other->compressed_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TemplightEntry_TemplateName::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TemplightEntry_TemplateName_descriptor_;
  metadata.reflection = TemplightEntry_TemplateName_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TemplightEntry_SourceLocation::kFileNameFieldNumber;
const int TemplightEntry_SourceLocation::kFileIdFieldNumber;
const int TemplightEntry_SourceLocation::kLineFieldNumber;
const int TemplightEntry_SourceLocation::kColumnFieldNumber;
#endif  // !_MSC_VER

TemplightEntry_SourceLocation::TemplightEntry_SourceLocation()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:TemplightEntry.SourceLocation)
}

void TemplightEntry_SourceLocation::InitAsDefaultInstance() {
}

TemplightEntry_SourceLocation::TemplightEntry_SourceLocation(const TemplightEntry_SourceLocation& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:TemplightEntry.SourceLocation)
}

void TemplightEntry_SourceLocation::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  file_id_ = 0u;
  line_ = 0u;
  column_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TemplightEntry_SourceLocation::~TemplightEntry_SourceLocation() {
  // @@protoc_insertion_point(destructor:TemplightEntry.SourceLocation)
  SharedDtor();
}

void TemplightEntry_SourceLocation::SharedDtor() {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_name_;
  }
  if (this != default_instance_) {
  }
}

void TemplightEntry_SourceLocation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TemplightEntry_SourceLocation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TemplightEntry_SourceLocation_descriptor_;
}

const TemplightEntry_SourceLocation& TemplightEntry_SourceLocation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_templight_5fmessages_2eproto();
  return *default_instance_;
}

TemplightEntry_SourceLocation* TemplightEntry_SourceLocation::default_instance_ = NULL;

TemplightEntry_SourceLocation* TemplightEntry_SourceLocation::New() const {
  return new TemplightEntry_SourceLocation;
}

void TemplightEntry_SourceLocation::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TemplightEntry_SourceLocation*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(file_id_, column_);
    if (has_file_name()) {
      if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        file_name_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TemplightEntry_SourceLocation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TemplightEntry.SourceLocation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string file_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->file_name().data(), this->file_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "file_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_file_id;
        break;
      }

      // required uint32 file_id = 2;
      case 2: {
        if (tag == 16) {
         parse_file_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &file_id_)));
          set_has_file_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_line;
        break;
      }

      // required uint32 line = 3;
      case 3: {
        if (tag == 24) {
         parse_line:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &line_)));
          set_has_line();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_column;
        break;
      }

      // optional uint32 column = 4;
      case 4: {
        if (tag == 32) {
         parse_column:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &column_)));
          set_has_column();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TemplightEntry.SourceLocation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TemplightEntry.SourceLocation)
  return false;
#undef DO_
}

void TemplightEntry_SourceLocation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TemplightEntry.SourceLocation)
  // optional string file_name = 1;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->file_name().data(), this->file_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "file_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->file_name(), output);
  }

  // required uint32 file_id = 2;
  if (has_file_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->file_id(), output);
  }

  // required uint32 line = 3;
  if (has_line()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->line(), output);
  }

  // optional uint32 column = 4;
  if (has_column()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->column(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TemplightEntry.SourceLocation)
}

::google::protobuf::uint8* TemplightEntry_SourceLocation::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TemplightEntry.SourceLocation)
  // optional string file_name = 1;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->file_name().data(), this->file_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "file_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->file_name(), target);
  }

  // required uint32 file_id = 2;
  if (has_file_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->file_id(), target);
  }

  // required uint32 line = 3;
  if (has_line()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->line(), target);
  }

  // optional uint32 column = 4;
  if (has_column()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->column(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TemplightEntry.SourceLocation)
  return target;
}

int TemplightEntry_SourceLocation::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string file_name = 1;
    if (has_file_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->file_name());
    }

    // required uint32 file_id = 2;
    if (has_file_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->file_id());
    }

    // required uint32 line = 3;
    if (has_line()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->line());
    }

    // optional uint32 column = 4;
    if (has_column()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->column());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TemplightEntry_SourceLocation::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TemplightEntry_SourceLocation* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TemplightEntry_SourceLocation*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TemplightEntry_SourceLocation::MergeFrom(const TemplightEntry_SourceLocation& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_file_name()) {
      set_file_name(from.file_name());
    }
    if (from.has_file_id()) {
      set_file_id(from.file_id());
    }
    if (from.has_line()) {
      set_line(from.line());
    }
    if (from.has_column()) {
      set_column(from.column());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TemplightEntry_SourceLocation::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TemplightEntry_SourceLocation::CopyFrom(const TemplightEntry_SourceLocation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TemplightEntry_SourceLocation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  return true;
}

void TemplightEntry_SourceLocation::Swap(TemplightEntry_SourceLocation* other) {
  if (other != this) {
    std::swap(file_name_, other->file_name_);
    std::swap(file_id_, other->file_id_);
    std::swap(line_, other->line_);
    std::swap(column_, other->column_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TemplightEntry_SourceLocation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TemplightEntry_SourceLocation_descriptor_;
  metadata.reflection = TemplightEntry_SourceLocation_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TemplightEntry_Begin::kKindFieldNumber;
const int TemplightEntry_Begin::kNameFieldNumber;
const int TemplightEntry_Begin::kLocationFieldNumber;
const int TemplightEntry_Begin::kTimeStampFieldNumber;
const int TemplightEntry_Begin::kMemoryUsageFieldNumber;
#endif  // !_MSC_VER

TemplightEntry_Begin::TemplightEntry_Begin()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:TemplightEntry.Begin)
}

void TemplightEntry_Begin::InitAsDefaultInstance() {
  name_ = const_cast< ::TemplightEntry_TemplateName*>(&::TemplightEntry_TemplateName::default_instance());
  location_ = const_cast< ::TemplightEntry_SourceLocation*>(&::TemplightEntry_SourceLocation::default_instance());
}

TemplightEntry_Begin::TemplightEntry_Begin(const TemplightEntry_Begin& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:TemplightEntry.Begin)
}

void TemplightEntry_Begin::SharedCtor() {
  _cached_size_ = 0;
  kind_ = 0;
  name_ = NULL;
  location_ = NULL;
  time_stamp_ = 0;
  memory_usage_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TemplightEntry_Begin::~TemplightEntry_Begin() {
  // @@protoc_insertion_point(destructor:TemplightEntry.Begin)
  SharedDtor();
}

void TemplightEntry_Begin::SharedDtor() {
  if (this != default_instance_) {
    delete name_;
    delete location_;
  }
}

void TemplightEntry_Begin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TemplightEntry_Begin::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TemplightEntry_Begin_descriptor_;
}

const TemplightEntry_Begin& TemplightEntry_Begin::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_templight_5fmessages_2eproto();
  return *default_instance_;
}

TemplightEntry_Begin* TemplightEntry_Begin::default_instance_ = NULL;

TemplightEntry_Begin* TemplightEntry_Begin::New() const {
  return new TemplightEntry_Begin;
}

void TemplightEntry_Begin::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TemplightEntry_Begin*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(time_stamp_, kind_);
    if (has_name()) {
      if (name_ != NULL) name_->::TemplightEntry_TemplateName::Clear();
    }
    if (has_location()) {
      if (location_ != NULL) location_->::TemplightEntry_SourceLocation::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TemplightEntry_Begin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TemplightEntry.Begin)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .TemplightEntry.InstantiationKind kind = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TemplightEntry_InstantiationKind_IsValid(value)) {
            set_kind(static_cast< ::TemplightEntry_InstantiationKind >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // required .TemplightEntry.TemplateName name = 2;
      case 2: {
        if (tag == 18) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_location;
        break;
      }

      // required .TemplightEntry.SourceLocation location = 3;
      case 3: {
        if (tag == 26) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_time_stamp;
        break;
      }

      // optional double time_stamp = 4;
      case 4: {
        if (tag == 33) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_memory_usage;
        break;
      }

      // optional uint64 memory_usage = 5;
      case 5: {
        if (tag == 40) {
         parse_memory_usage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &memory_usage_)));
          set_has_memory_usage();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TemplightEntry.Begin)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TemplightEntry.Begin)
  return false;
#undef DO_
}

void TemplightEntry_Begin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TemplightEntry.Begin)
  // required .TemplightEntry.InstantiationKind kind = 1;
  if (has_kind()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->kind(), output);
  }

  // required .TemplightEntry.TemplateName name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->name(), output);
  }

  // required .TemplightEntry.SourceLocation location = 3;
  if (has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->location(), output);
  }

  // optional double time_stamp = 4;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->time_stamp(), output);
  }

  // optional uint64 memory_usage = 5;
  if (has_memory_usage()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->memory_usage(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TemplightEntry.Begin)
}

::google::protobuf::uint8* TemplightEntry_Begin::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TemplightEntry.Begin)
  // required .TemplightEntry.InstantiationKind kind = 1;
  if (has_kind()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->kind(), target);
  }

  // required .TemplightEntry.TemplateName name = 2;
  if (has_name()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->name(), target);
  }

  // required .TemplightEntry.SourceLocation location = 3;
  if (has_location()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->location(), target);
  }

  // optional double time_stamp = 4;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->time_stamp(), target);
  }

  // optional uint64 memory_usage = 5;
  if (has_memory_usage()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->memory_usage(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TemplightEntry.Begin)
  return target;
}

int TemplightEntry_Begin::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .TemplightEntry.InstantiationKind kind = 1;
    if (has_kind()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->kind());
    }

    // required .TemplightEntry.TemplateName name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->name());
    }

    // required .TemplightEntry.SourceLocation location = 3;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->location());
    }

    // optional double time_stamp = 4;
    if (has_time_stamp()) {
      total_size += 1 + 8;
    }

    // optional uint64 memory_usage = 5;
    if (has_memory_usage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->memory_usage());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TemplightEntry_Begin::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TemplightEntry_Begin* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TemplightEntry_Begin*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TemplightEntry_Begin::MergeFrom(const TemplightEntry_Begin& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kind()) {
      set_kind(from.kind());
    }
    if (from.has_name()) {
      mutable_name()->::TemplightEntry_TemplateName::MergeFrom(from.name());
    }
    if (from.has_location()) {
      mutable_location()->::TemplightEntry_SourceLocation::MergeFrom(from.location());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_memory_usage()) {
      set_memory_usage(from.memory_usage());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TemplightEntry_Begin::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TemplightEntry_Begin::CopyFrom(const TemplightEntry_Begin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TemplightEntry_Begin::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_location()) {
    if (!this->location().IsInitialized()) return false;
  }
  return true;
}

void TemplightEntry_Begin::Swap(TemplightEntry_Begin* other) {
  if (other != this) {
    std::swap(kind_, other->kind_);
    std::swap(name_, other->name_);
    std::swap(location_, other->location_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(memory_usage_, other->memory_usage_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TemplightEntry_Begin::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TemplightEntry_Begin_descriptor_;
  metadata.reflection = TemplightEntry_Begin_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TemplightEntry_End::kTimeStampFieldNumber;
const int TemplightEntry_End::kMemoryUsageFieldNumber;
#endif  // !_MSC_VER

TemplightEntry_End::TemplightEntry_End()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:TemplightEntry.End)
}

void TemplightEntry_End::InitAsDefaultInstance() {
}

TemplightEntry_End::TemplightEntry_End(const TemplightEntry_End& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:TemplightEntry.End)
}

void TemplightEntry_End::SharedCtor() {
  _cached_size_ = 0;
  time_stamp_ = 0;
  memory_usage_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TemplightEntry_End::~TemplightEntry_End() {
  // @@protoc_insertion_point(destructor:TemplightEntry.End)
  SharedDtor();
}

void TemplightEntry_End::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TemplightEntry_End::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TemplightEntry_End::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TemplightEntry_End_descriptor_;
}

const TemplightEntry_End& TemplightEntry_End::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_templight_5fmessages_2eproto();
  return *default_instance_;
}

TemplightEntry_End* TemplightEntry_End::default_instance_ = NULL;

TemplightEntry_End* TemplightEntry_End::New() const {
  return new TemplightEntry_End;
}

void TemplightEntry_End::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TemplightEntry_End*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(time_stamp_, memory_usage_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TemplightEntry_End::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TemplightEntry.End)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double time_stamp = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_memory_usage;
        break;
      }

      // optional uint64 memory_usage = 2;
      case 2: {
        if (tag == 16) {
         parse_memory_usage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &memory_usage_)));
          set_has_memory_usage();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TemplightEntry.End)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TemplightEntry.End)
  return false;
#undef DO_
}

void TemplightEntry_End::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TemplightEntry.End)
  // optional double time_stamp = 1;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->time_stamp(), output);
  }

  // optional uint64 memory_usage = 2;
  if (has_memory_usage()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->memory_usage(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TemplightEntry.End)
}

::google::protobuf::uint8* TemplightEntry_End::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TemplightEntry.End)
  // optional double time_stamp = 1;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->time_stamp(), target);
  }

  // optional uint64 memory_usage = 2;
  if (has_memory_usage()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->memory_usage(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TemplightEntry.End)
  return target;
}

int TemplightEntry_End::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional double time_stamp = 1;
    if (has_time_stamp()) {
      total_size += 1 + 8;
    }

    // optional uint64 memory_usage = 2;
    if (has_memory_usage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->memory_usage());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TemplightEntry_End::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TemplightEntry_End* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TemplightEntry_End*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TemplightEntry_End::MergeFrom(const TemplightEntry_End& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_memory_usage()) {
      set_memory_usage(from.memory_usage());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TemplightEntry_End::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TemplightEntry_End::CopyFrom(const TemplightEntry_End& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TemplightEntry_End::IsInitialized() const {

  return true;
}

void TemplightEntry_End::Swap(TemplightEntry_End* other) {
  if (other != this) {
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(memory_usage_, other->memory_usage_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TemplightEntry_End::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TemplightEntry_End_descriptor_;
  metadata.reflection = TemplightEntry_End_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TemplightEntry::kBeginFieldNumber;
const int TemplightEntry::kEndFieldNumber;
#endif  // !_MSC_VER

TemplightEntry::TemplightEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:TemplightEntry)
}

void TemplightEntry::InitAsDefaultInstance() {
  begin_ = const_cast< ::TemplightEntry_Begin*>(&::TemplightEntry_Begin::default_instance());
  end_ = const_cast< ::TemplightEntry_End*>(&::TemplightEntry_End::default_instance());
}

TemplightEntry::TemplightEntry(const TemplightEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:TemplightEntry)
}

void TemplightEntry::SharedCtor() {
  _cached_size_ = 0;
  begin_ = NULL;
  end_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TemplightEntry::~TemplightEntry() {
  // @@protoc_insertion_point(destructor:TemplightEntry)
  SharedDtor();
}

void TemplightEntry::SharedDtor() {
  if (this != default_instance_) {
    delete begin_;
    delete end_;
  }
}

void TemplightEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TemplightEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TemplightEntry_descriptor_;
}

const TemplightEntry& TemplightEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_templight_5fmessages_2eproto();
  return *default_instance_;
}

TemplightEntry* TemplightEntry::default_instance_ = NULL;

TemplightEntry* TemplightEntry::New() const {
  return new TemplightEntry;
}

void TemplightEntry::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_begin()) {
      if (begin_ != NULL) begin_->::TemplightEntry_Begin::Clear();
    }
    if (has_end()) {
      if (end_ != NULL) end_->::TemplightEntry_End::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TemplightEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TemplightEntry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .TemplightEntry.Begin begin = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_begin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_end;
        break;
      }

      // optional .TemplightEntry.End end = 2;
      case 2: {
        if (tag == 18) {
         parse_end:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_end()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TemplightEntry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TemplightEntry)
  return false;
#undef DO_
}

void TemplightEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TemplightEntry)
  // optional .TemplightEntry.Begin begin = 1;
  if (has_begin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->begin(), output);
  }

  // optional .TemplightEntry.End end = 2;
  if (has_end()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->end(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TemplightEntry)
}

::google::protobuf::uint8* TemplightEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TemplightEntry)
  // optional .TemplightEntry.Begin begin = 1;
  if (has_begin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->begin(), target);
  }

  // optional .TemplightEntry.End end = 2;
  if (has_end()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->end(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TemplightEntry)
  return target;
}

int TemplightEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .TemplightEntry.Begin begin = 1;
    if (has_begin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->begin());
    }

    // optional .TemplightEntry.End end = 2;
    if (has_end()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->end());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TemplightEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TemplightEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TemplightEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TemplightEntry::MergeFrom(const TemplightEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_begin()) {
      mutable_begin()->::TemplightEntry_Begin::MergeFrom(from.begin());
    }
    if (from.has_end()) {
      mutable_end()->::TemplightEntry_End::MergeFrom(from.end());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TemplightEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TemplightEntry::CopyFrom(const TemplightEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TemplightEntry::IsInitialized() const {

  if (has_begin()) {
    if (!this->begin().IsInitialized()) return false;
  }
  return true;
}

void TemplightEntry::Swap(TemplightEntry* other) {
  if (other != this) {
    std::swap(begin_, other->begin_);
    std::swap(end_, other->end_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TemplightEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TemplightEntry_descriptor_;
  metadata.reflection = TemplightEntry_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TemplightTrace::kHeaderFieldNumber;
const int TemplightTrace::kEntriesFieldNumber;
#endif  // !_MSC_VER

TemplightTrace::TemplightTrace()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:TemplightTrace)
}

void TemplightTrace::InitAsDefaultInstance() {
  header_ = const_cast< ::TemplightHeader*>(&::TemplightHeader::default_instance());
}

TemplightTrace::TemplightTrace(const TemplightTrace& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:TemplightTrace)
}

void TemplightTrace::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TemplightTrace::~TemplightTrace() {
  // @@protoc_insertion_point(destructor:TemplightTrace)
  SharedDtor();
}

void TemplightTrace::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void TemplightTrace::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TemplightTrace::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TemplightTrace_descriptor_;
}

const TemplightTrace& TemplightTrace::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_templight_5fmessages_2eproto();
  return *default_instance_;
}

TemplightTrace* TemplightTrace::default_instance_ = NULL;

TemplightTrace* TemplightTrace::New() const {
  return new TemplightTrace;
}

void TemplightTrace::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::TemplightHeader::Clear();
  }
  entries_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TemplightTrace::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TemplightTrace)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .TemplightHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_entries;
        break;
      }

      // repeated .TemplightEntry entries = 2;
      case 2: {
        if (tag == 18) {
         parse_entries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entries()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_entries;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TemplightTrace)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TemplightTrace)
  return false;
#undef DO_
}

void TemplightTrace::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TemplightTrace)
  // required .TemplightHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }

  // repeated .TemplightEntry entries = 2;
  for (int i = 0; i < this->entries_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->entries(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TemplightTrace)
}

::google::protobuf::uint8* TemplightTrace::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TemplightTrace)
  // required .TemplightHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }

  // repeated .TemplightEntry entries = 2;
  for (int i = 0; i < this->entries_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->entries(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TemplightTrace)
  return target;
}

int TemplightTrace::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .TemplightHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }

  }
  // repeated .TemplightEntry entries = 2;
  total_size += 1 * this->entries_size();
  for (int i = 0; i < this->entries_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entries(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TemplightTrace::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TemplightTrace* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TemplightTrace*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TemplightTrace::MergeFrom(const TemplightTrace& from) {
  GOOGLE_CHECK_NE(&from, this);
  entries_.MergeFrom(from.entries_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::TemplightHeader::MergeFrom(from.header());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TemplightTrace::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TemplightTrace::CopyFrom(const TemplightTrace& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TemplightTrace::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->entries())) return false;
  return true;
}

void TemplightTrace::Swap(TemplightTrace* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    entries_.Swap(&other->entries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TemplightTrace::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TemplightTrace_descriptor_;
  metadata.reflection = TemplightTrace_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TemplightTraceCollection::kTracesFieldNumber;
#endif  // !_MSC_VER

TemplightTraceCollection::TemplightTraceCollection()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:TemplightTraceCollection)
}

void TemplightTraceCollection::InitAsDefaultInstance() {
}

TemplightTraceCollection::TemplightTraceCollection(const TemplightTraceCollection& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:TemplightTraceCollection)
}

void TemplightTraceCollection::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TemplightTraceCollection::~TemplightTraceCollection() {
  // @@protoc_insertion_point(destructor:TemplightTraceCollection)
  SharedDtor();
}

void TemplightTraceCollection::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TemplightTraceCollection::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TemplightTraceCollection::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TemplightTraceCollection_descriptor_;
}

const TemplightTraceCollection& TemplightTraceCollection::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_templight_5fmessages_2eproto();
  return *default_instance_;
}

TemplightTraceCollection* TemplightTraceCollection::default_instance_ = NULL;

TemplightTraceCollection* TemplightTraceCollection::New() const {
  return new TemplightTraceCollection;
}

void TemplightTraceCollection::Clear() {
  traces_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TemplightTraceCollection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TemplightTraceCollection)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .TemplightTrace traces = 1;
      case 1: {
        if (tag == 10) {
         parse_traces:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_traces()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_traces;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TemplightTraceCollection)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TemplightTraceCollection)
  return false;
#undef DO_
}

void TemplightTraceCollection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TemplightTraceCollection)
  // repeated .TemplightTrace traces = 1;
  for (int i = 0; i < this->traces_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->traces(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TemplightTraceCollection)
}

::google::protobuf::uint8* TemplightTraceCollection::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TemplightTraceCollection)
  // repeated .TemplightTrace traces = 1;
  for (int i = 0; i < this->traces_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->traces(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TemplightTraceCollection)
  return target;
}

int TemplightTraceCollection::ByteSize() const {
  int total_size = 0;

  // repeated .TemplightTrace traces = 1;
  total_size += 1 * this->traces_size();
  for (int i = 0; i < this->traces_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->traces(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TemplightTraceCollection::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TemplightTraceCollection* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TemplightTraceCollection*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TemplightTraceCollection::MergeFrom(const TemplightTraceCollection& from) {
  GOOGLE_CHECK_NE(&from, this);
  traces_.MergeFrom(from.traces_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TemplightTraceCollection::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TemplightTraceCollection::CopyFrom(const TemplightTraceCollection& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TemplightTraceCollection::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->traces())) return false;
  return true;
}

void TemplightTraceCollection::Swap(TemplightTraceCollection* other) {
  if (other != this) {
    traces_.Swap(&other->traces_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TemplightTraceCollection::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TemplightTraceCollection_descriptor_;
  metadata.reflection = TemplightTraceCollection_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
